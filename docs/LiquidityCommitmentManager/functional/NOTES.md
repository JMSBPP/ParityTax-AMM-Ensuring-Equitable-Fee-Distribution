# `LiquidityCommitmmentManager`

## Mechanism Design

- LiquidityCommitment is better enforced via routers specifying the commmitment in callback data:

  -  If it's JIT their funds will be put on `vaults` where a `JITHook` execute the JIT liquidity for the trades, this `JITHook` has an `afterSwap` where `feeRevenue` is tracked.
  
  -  If its PLP their funds will be also put on `vaults` but with `withdrawalLocks`
  __enabling__ visible ex-ante liquidity for traders, the difference is that the funds on the `vaults` can earn passive income while locked and also receive the tax revenue generated by JIT's income transfer.

## Services

### `setTimeCommitment`
````solidity
contract ModifyLiquidityRouter{
    function  modifyLiquidity(
        PoolKey memory key, 
        ModifyLiquidityParams memory params, 
        bytes memory hookData
        ) external payable (BalanceDelta delta){
            // Is hook Data a time Commitment ?
            bytes memory encodedTimeCommitment = validateHookData(hookData); // This verifies that hookData decodes to a time commitment
            // struct
            delta = abi.decode(
                    manager.unlock(
                        abi.encode(
                            CallbackData({
                                sender: msg.sender,
                                PoolKey: key, 
                                liquidityParams: params,
                                hookData: encodedTimeCommitment,
                                settleUsingBurn: // Claims related Ignored from now,
                                takeClaims:// Claims related Ignored from now, 
                            }),
                        (BalanceDelta)
                        )
                    )
                );
            // If it is ETH being sent, it handles that case ...
        }
}
// ==========================FLOW STATUS======================================
// router.modifyLiquidity()->manager.unlock() 
contract PoolManager{
    function unlock(
        bytes calldata data
        )
        external
        override
        returns (bytes memory result) {
        if (Lock.isUnlocked()) AlreadyUnlocked.selector.revertWith();

        Lock.unlock();

        // the caller does everything in this callback, including paying what they owe via calls to settle
        result = IUnlockCallback(msg.sender).unlockCallback(data);

        if (NonzeroDeltaCount.read() != 0) CurrencyNotSettled.selector.revertWith();
        Lock.lock();
    }
}
// ==========================NOTES======================================

// Notice we do not have control over manager.unlock, but we do over
// router either on modifyLiquidity and/or unlockCallback()
// ====LiquidityRouter.modifyLiquidity():===
// ----
// --> Besides checking for the correct hookData
//  --> Is there anything else that this function can call ?
// The answer is yes, because if the LP is asking to withdraw liquidity on the params, then the following needs to follow:
// 1. hookData is irrelevant becuase timeCommitment is only enforced when ading liquidity
// However there is already a record of this LP Posiyion, we need to verify that
// the timeCommitment for the position already expired 
// ==========================FLOW STATUS======================================

// router.modifyLiquidity()->manager.unlock() -> router.unlockCallback()

contract ModifyLiquidityRouter{

    function unlockCallback
        (
            bytes calldata rawData
        )
        external
        returns (bytes memory){
            //1. It needs to check that the caller is the poolManager
            //2. It needs to decode the Callback data, and consequently
            // the TimeCommitment data inside it
            // 3. It retrieves the liquidity that is already on the specified
            // params where the LP is looking to add liquidity ADDITIONALLY
            // it needs to verify wheter is PLP or JIT the existing position if
            // any
            // It can only add more liquidity if the exiting position is the same
            // type, this is:
            // ---> If the existing position is PLP and the new liquidity request has other PLP params, it needs to adjust the position accordingly
            // ---> If the existing position is JIT and the request is JIT it only add more funds to the vaults
            // ---> If the existing position is PLP and the new liquidity request is JIT it returns incompatiblePositions Error or handles it appropiately, this is TBD
            // ---> If the existing position is JIT and the new liquidity request is PLP it returns incompatiblePositions Error or handles it appropiately, this is TBD
        }
}






> Not special mechanism is done for traders then the router is only for modifyLiquidity.
Hence inherits `PositionManager` services.

