## Random
- We need to find how when
  `modifyLiquidity{msg.sender}(key, liquidityParams)` is being tracked
1. How do I retreive with an external call the Pool.State
   
```solidity
  function modifyLiquidity(State storage self, ModifyLiquidityParams memory params)
      internal
      returns (BalanceDelta delta, BalanceDelta feeDelta)
  {
      int128 liquidityDelta = params.liquidityDelta;
      int24 tickLower = params.tickLower;
      int24 tickUpper = params.tickUpper;
      checkTicks(tickLower, tickUpper);

      {
        // UPDATING GLOBAL POOL LIQUIDITY
      }

      {
          // UPDATE LP POSITION 
            (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =
                  getFeeGrowthInside(self, tickLower, tickUpper);

              Position.State storage position = self.positions.get(params.owner, tickLower, tickUpper, params.salt);
              (uint256 feesOwed0, uint256 feesOwed1) =
                  position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);

              // Fees earned from LPing are calculated, and returned
              feeDelta = toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());
      }

          // clear any tick data that is no longer needed
          if (liquidityDelta < 0) {
              if (state.flippedLower) {
                  clearTick(self, tickLower);
              }
              if (state.flippedUpper) {
                  clearTick(self, tickUpper);
              }
          }
      }

      if (liquidityDelta != 0) {
          Slot0 _slot0 = self.slot0;
          (int24 tick, uint160 sqrtPriceX96) = (_slot0.tick(), _slot0.sqrtPriceX96());
          if (tick < tickLower) {
              // current tick is below the passed range; liquidity can only become in range by crossing from left to
              // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it
              delta = toBalanceDelta(
                  SqrtPriceMath.getAmount0Delta(
                      TickMath.getSqrtPriceAtTick(tickLower), TickMath.getSqrtPriceAtTick(tickUpper), liquidityDelta
                  ).toInt128(),
                  0
              );
          } else if (tick < tickUpper) {
              delta = toBalanceDelta(
                  SqrtPriceMath.getAmount0Delta(sqrtPriceX96, TickMath.getSqrtPriceAtTick(tickUpper), liquidityDelta)
                      .toInt128(),
                  SqrtPriceMath.getAmount1Delta(TickMath.getSqrtPriceAtTick(tickLower), sqrtPriceX96, liquidityDelta)
                      .toInt128()
              );

              self.liquidity = LiquidityMath.addDelta(self.liquidity, liquidityDelta);
          } else {
              // current tick is above the passed range; liquidity can only become in range by crossing from right to
              // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it
              delta = toBalanceDelta(
                  0,
                  SqrtPriceMath.getAmount1Delta(
                      TickMath.getSqrtPriceAtTick(tickLower), TickMath.getSqrtPriceAtTick(tickUpper), liquidityDelta
                  ).toInt128()
              );
          }
      }
  }
```

## Problem

- $\eta_{V^{NOISE}/L} < \eta^{\star}_{V^{NOISE}/L} \implies \Pi^{JIT} >> \Pi^{PLP} \implies \downarrow L^{PLP} \implies \downarrow L$

- Traders do not swap in the absence of
passive market liquidity, or even considering the anticipation of JIT LPs filling them.The concern here is that JIT liquidity might be minimal, leading to large price impacts for the traders as JIT LPs, who move after the traders, can limit their liquidity supply to earn a large price impact in such
cases.


In equilibrium, the amount of liquidity provided by the JIT LP is not arbitrarily large, but is rather
a fixed multiple of the existing passive liquidity. This is due to a critical balance the JIT LP must strike
between two factors: the marginal benefit of acquiring a larger share of the pool’s fees by increasing their
deposit, and the marginal loss from a lower price impact caused by a deeper liquidity pool. If the JIT LP
were to deposit an excessively large amount, the resulting depth of the liquidity pool would significantly
diminish the price impact of traders’ swaps, leading to a decrease in gains the JIT LP could expect from price
movements generated by these trades.

 This underscores the critical roles of passive LPs as both a safety net and an alternative for traders,
protecting them from predatory practices by JIT LPs analogous to the way HFT firms prey on large orders


### Target Audience:
**Non-sophisticated PLP's commiting capital over multiple block times**
- Automating re-rebalancing has a cost, even though there protocols that do it for you.

This hook is designed to provide fair conditions for PLP's
//TODO:
- Reasons why someone is willing to be PLP.

PLP's are retail, is reasonable to think they see value on CCTP (Circle) and also pay their gas with USDc (Paymaster (Circle))



# Design Analysis

## `ParityTaxHook`  
  -  `ParityTax-hook` **subscribes** to `JIT-Liquidity-hooks`
  
  -  `TimeLockedPositionManager` **tracks** fees to each `LP's account`
  
  -  `FeeCalculations` consider the __fee size, LP's share of the pool, pool's fee specification__
### `Commitment Duration Specification`

  -  `beforeDepositingLiquidity` an **LP** must specify a commitment duration level `IERC7818.mint(commitmentLevel)`, the more commitment Level the more long-term commitment on liquidity.
  
  -  `commitmentLevel` classifies PLP's and JIT 

### `Enforcement of Commitment`

  -   `[IERC7818.balanceOf(LP)==0]beforeRemoveLiquidity:` the __fees__ tracked by the `globalFeeTracker`.
  
### `Tax System`  

  - `TaxSystem` **establishes** a tax parameter $\tau \in [0,1]$.
  
  - `TaxSystem` **tracks** two separate global fee variables (`globalFeePLP's, globalFeeJIT`).

### `FeeDistributionDuringSwaps`

- `beforeSwap() => FeeDistribution.computeLPShares()`


    


## How a standard `JIT-Liquidity-hook` looks like ?

- We have a detector that identifies