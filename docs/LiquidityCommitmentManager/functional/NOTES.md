# `LiquidityCommitmmentManager`

- LiquidityCommitment is better enforced via routers specifying the commmitment in callback data:

  -  If it's JIT their funds will be put on `vaults` where a `JITHook` execute the JIT liquidity for the trades, this `JITHook` has an `afterSwap` where `feeRevenue` is tracked.
  
  -  If its PLP their funds will be also put on `vaults` but with `withdrawalLocks`
  __enabling__ visible ex-ante liquidity for traders, the difference is that the funds on the `vaults` can earn passive income while locked and also receive the tax revenue generated by JIT's income transfer.

## Services

### `setTimeCommitment`
```solidity
contract ModifyLiquidityRouter{
    function  modifyLiquidity(
        PoolKey memory key, 
        ModifyLiquidityParams memory params, 
        bytes memory hookData
        ) external payable (BalanceDelta delta){
            // Is hook Data a time Commitment ?
            bytes memory encodedTimeCommitment = validateHookData(hookData); // This verifies that hookData decodes to a time commitment
            // struct
            delta = abi.decode(
                    manager.unlock(
                        abi.encode(
                            CallbackData({
                                sender: msg.sender,
                                PoolKey: key, 
                                liquidityParams: params,
                                hookData: encodedTimeCommitment,
                                settleUsingBurn: // Claims related Ignored from now,
                                takeClaims:// Claims related Ignored from now, 
                            }),
                        (BalanceDelta)
                        )
                    )
                );
            // If it is ETH being sent, it handles that case ...
        }
}
// ==========================FLOW STATUS======================================
// router.modifyLiquidity()->manager.unlock() 
contract PoolManager{
    function unlock(
        bytes calldata data
        )
        external
        override
        returns (bytes memory result) {
        if (Lock.isUnlocked()) AlreadyUnlocked.selector.revertWith();

        Lock.unlock();

        // the caller does everything in this callback, including paying what they owe via calls to settle
        result = IUnlockCallback(msg.sender).unlockCallback(data);

        if (NonzeroDeltaCount.read() != 0) CurrencyNotSettled.selector.revertWith();
        Lock.lock();
    }
}
// ==========================NOTES======================================

// Notice we do not have control over manager.unlock, but we do over
// router either on modifyLiquidity and/or unlockCallback()
// ====LiquidityRouter.modifyLiquidity():===
// If the LP is asking to withdraw liquidity on the params, then the following needs to follow:
// 1. hookData is irrelevant because timeCommitment is only enforced when ading liquidity
// However there is already a record of this LP Position, we need to verify that
// the timeCommitment for the position already expired 
// ==========================FLOW STATUS======================================

//router.modifyLiquidity()-> manager.unlock() -> router.unlockCallback()

contract ModifyLiquidityRouter{

    function unlockCallback
        (
            bytes calldata rawData
        )
        external
        returns (bytes memory){
            //1. It needs to check that the caller is the poolManager
            //2. It needs to decode the Callback data, and consequently
            // the TimeCommitment data inside it

        }
}
```

- After this `liquidityRouter` sends the `callBackData`  to the `poolManager`, from this point on because the `poolManager` is _immutable_ , it forwards the `CallbackData` to the `LiquidityCommitmentManagerHook` where `beforeAddLiquidity` will be in charge of routing the `callbackData` accordingly, this is:



- This implies that `beforeAddLiquidity` is `NoOp-Hook` since liquidity will not be added from here, but from the `LP-vaults`.








> Not special mechanism is done for traders then the router is only for modifyLiquidity.
Hence inherits `PositionManager` services.

